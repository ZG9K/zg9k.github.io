<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Desktop ARG — Base Template</title>
<link rel="stylesheet" href="https://use.typekit.net/dsm0ynv.css">
<style>
  :root{
    --chrome:#000;
    --surface:#fff;
    --pane:#dedede;
    --accent:#b4b4b4;
    --dock:#c0c0c0;
    --font: 'geneva-9-1', lores-9-narrow, ui-monospace, monospace;
  }

  /* ---- Fonts ---- */
  @font-face {
    font-family: 'geneva-9-1';
    src: url('assets/fonts/geneva-9-1.otf') format('opentype');
    font-weight: normal; font-style: normal;
  }

  /* ---- Desktop ---- */
  html,body{height:100%;margin:0;background:#fff;
    background-image:repeating-conic-gradient(#000 0% 25%, #fff 0% 50%);
    background-size:2px 2px; font-family:var(--font); user-select:none; cursor:default; overflow:hidden}
  #desktop{position:relative;width:100%;height:calc(100% - 42px)}
  /* ---- Dock ---- */
  #dock{position:fixed;left:0;right:0;bottom:0;height:42px;background:var(--dock);
    border-top:2px solid var(--chrome);display:flex;align-items:center;gap:6px;padding:4px 8px}
  #dock .dock-item{height:30px;padding:0 8px;display:flex;align-items:center;gap:6px;border:2px solid var(--chrome);
    background:#fff; font-size:12px}
  #dock .dock-item strong{font-weight:700}

  /* ---- Window ---- */
  .window{position:absolute;display:flex;flex-direction:column;background:var(--surface);min-width:160px;min-height:120px;
    box-shadow:0 0 0 2px var(--chrome),0 0 0 3px #fff,0 0 0 5px var(--chrome)}
  .titlebar{height:12px;background:var(--chrome);color:#fff;padding:0 6px 2px 6px;display:flex;align-items:center;gap:6px;cursor:move;
    box-shadow:5px -5px 0 0 var(--chrome), -5px -5px 0 0 var(--chrome),-5px 0 0 0 var(--chrome),5px 0 0 0 var(--chrome)}
  .title{font-size:12px; transform:translate(-4px,-2px)}
  .titlebar .spacer{flex:1}
  .titlebar .close{appearance:none;border:none;background:#fff;color:#000;font-weight:700;line-height:1;cursor:pointer;padding:0 4px}
  .titlebar .close:hover{background:#696969;color:#fff}
  .content{flex:1;overflow:auto;background:var(--pane);padding:6px}
  p{margin:0 0 6px}
  .highlight{background:var(--accent);color:#fff;padding:2px 4px;display:inline-block}
  .blink{animation:blink 1s steps(1,end) infinite} @keyframes blink{50%{opacity:0}}
  a{color:#000;text-decoration:none;font-weight:700} a:hover{text-shadow:#858585 0 1px 0}

  /* ---- Terminal ---- */
  .terminal{font-size:14px;text-align:center}
  .terminal input{width:100%;font:inherit;border:none;background:transparent;
    background-image:repeating-conic-gradient(#000 0% 25%, #fff 0% 50%); background-size:2px 2px; padding:6px}
  .terminal button{font:inherit;border:none;background:#fff;box-shadow:inset -1px -1px 0 #000, inset 1px 1px 0 #fff; padding:4px 8px}
  .terminal button:hover{background:var(--accent);box-shadow:inset -1px -1px 0 #fff, inset 1px 1px 0 #000}

  /* ---- Scan mode ---- */
  .scan-only{display:none}
  body.scan-enabled .window[data-scan-target="1"] .scan-only{display:block}
  .scan-overlay{position:absolute;inset:6px;pointer-events:none;display:none}
  body.scan-enabled .window[data-scan-target="1"] .scan-overlay{display:block;mix-blend-mode:multiply}
  /* simple diagonal lines placeholder overlay */
  .scan-overlay::before{
    content:""; position:absolute; inset:0;
    background-image: repeating-linear-gradient(45deg, rgba(0,0,0,.18) 0 2px, transparent 2px 6px);
  }
  /* contrast controlled by inline style on .content via JS */

  /* ---- Scanner panel ---- */
  #scanner{position:fixed;right:0;top:0;width:260px;height:calc(100% - 42px);background:#eee;border-left:2px solid #000;
    display:none;flex-direction:column;font-size:12px}
  #scanner header{background:#000;color:#fff;padding:6px 8px}
  #scanner .pane{padding:8px;flex:1;overflow:auto}
  #scanner label{display:block;margin:8px 0 4px}
  #scanner .kv{font-family:var(--font)}
  #scanner .kv div{display:flex;gap:6px}
  #scanner .kv div span:first-child{width:80px;color:#333}

  body.scan-enabled #scanner{display:flex}

  /* ---- Listen stub ---- */
  #listenLamp{position:fixed;left:8px;bottom:48px;display:none;align-items:center;gap:6px;background:#fff;border:2px solid #000;padding:2px 6px}
  #listenLamp .dot{width:8px;height:8px;border:1px solid #000;background:#0f0;animation:pulse 1.3s infinite}
  @keyframes pulse{0%{opacity:.3}50%{opacity:1}100%{opacity:.3}}
  body.listen-enabled #listenLamp{display:flex}

  /* ---- Toasts ---- */
  #toasts{position:fixed;right:10px;bottom:52px;display:flex;flex-direction:column;gap:6px;z-index:9999}
  .toast{background:#fff;border:2px solid #000;padding:4px 8px;font-size:12px}

</style>
</head>
<body>
<div id="desktop"></div>
<div id="scanner">
  <header>scan inspector</header>
  <div class="pane" id="scanMeta">
    <div class="kv" id="scanMetaRows"></div>
    <label>contrast</label>
    <input id="scanContrast" type="range" min="1" max="300" value="100"/>
    <label>notes</label>
    <div id="scanNotes" style="white-space:pre-wrap"></div>
  </div>
</div>
<div id="listenLamp"><div class="dot"></div><div>[listen] on</div></div>
<div id="toasts"></div>
<div id="dock"></div>

<script>
/* ===========================================================
   Minimal Desktop ARG Framework
   - WindowManager: create/open/close/drag/stack
   - Commands: registerCommand(name, {desc, usage, handler})
   - Scan system: body.scan-enabled + inspector for target window
   - Listen stub: UI lamp
   =========================================================== */

(function(){
  const desktop = document.getElementById('desktop');
  const dock    = document.getElementById('dock');
  const toasts  = document.getElementById('toasts');

  /* ---------------- Toasts ---------------- */
  function toast(msg){
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = msg;
    toasts.appendChild(el);
    setTimeout(()=>{ el.remove(); }, 2600);
  }

  /* ---------------- Z index helper ---------------- */
  function nextZ(){
    let z=0;
    for(const w of desktop.children) z = Math.max(z, +w.style.zIndex || 0);
    return z+1;
  }

  /* ---------------- Window Manager ---------------- */
  const WM = (() => {
    const registry = new Map(); // id -> spec
    const openMap  = new Map(); // id -> element

    function registerWindow(id, spec){
      registry.set(id, spec); // {title, x,y,w,h, render(el), meta:{}}
    }

    function getWindowEl(id){ return openMap.get(id); }

    function bringToFront(win){ win.style.zIndex = nextZ(); }

function makeDraggable(win) {
  const bar = win.querySelector('.titlebar');
  let dragging = false;
  let startX = 0, startY = 0;
  let startLeft = 0, startTop = 0;

  function bringToFront() {
    let z = 0;
    for (const child of document.getElementById('desktop').children) {
      z = Math.max(z, +child.style.zIndex || 0);
    }
    win.style.zIndex = z + 1;
  }

  function onMouseDown(e) {
    if (e.button !== 0) return;                    // left click only
    if (e.target.closest('.close')) return;        // ignore close button
    dragging = true;
    bringToFront();

    const rect = win.getBoundingClientRect();
    startX = e.clientX;
    startY = e.clientY;
    // use viewport coords so we don't accumulate rounding errors
    startLeft = rect.left;
    startTop  = rect.top;

    // visual feedback (optional)
    bar.style.cursor = 'grabbing';

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp, { once: true });

    // prevent text selection while dragging
    e.preventDefault();
  }

  function onMouseMove(e) {
    if (!dragging) return;

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    let nextLeft = startLeft + dx;
    let nextTop  = startTop + dy;

    // keep inside viewport (42px dock)
    const maxLeft = window.innerWidth  - win.offsetWidth;
    const maxTop  = window.innerHeight - 42 - win.offsetHeight;

    if (nextLeft < 0) nextLeft = 0;
    if (nextTop  < 0) nextTop  = 0;
    if (nextLeft > maxLeft) nextLeft = maxLeft;
    if (nextTop  > maxTop)  nextTop  = maxTop;

    win.style.left = nextLeft + 'px';
    win.style.top  = nextTop  + 'px';
  }

  function onMouseUp() {
    dragging = false;
    bar.style.cursor = 'move';
    document.removeEventListener('mousemove', onMouseMove);
  }

  // start drag on titlebar only
  bar.addEventListener('mousedown', onMouseDown);

  // also bring to front when clicking anywhere in the window
  win.addEventListener('mousedown', bringToFront);
}

    function addDockItem(id, title){
      const item = document.createElement('button');
      item.className = 'dock-item';
      item.innerHTML = `<strong>●</strong> ${title}`;
      item.addEventListener('click', ()=> open(id));
      dock.appendChild(item);
      return item;
    }

    function removeDockItem(node){ node && node.remove(); }

    function createShell(id, spec){
      const win = document.createElement('div');
      win.className = 'window';
      win.dataset.id = id;
      win.style.left = (spec.x ?? 80) + 'px';
      win.style.top  = (spec.y ?? 80) + 'px';
      win.style.width= (spec.w ?? 360) + 'px';
      win.style.height=(spec.h?? 220) + 'px';
      win.style.zIndex = nextZ();

      win.innerHTML = `
        <div class="titlebar">
          <span class="title">${spec.title ?? id}</span>
          <span class="spacer"></span>
          <button class="close" title="close" aria-label="close">×</button>
        </div>
        <div class="content"></div>`;
      desktop.appendChild(win);
      makeDraggable(win);

      // Close
      const closeBtn = win.querySelector('.close');
      closeBtn.addEventListener('click', ()=>{
        win.remove();
        openMap.delete(id);
        const dk = win.__dockItem;
        removeDockItem(dk);
      });

      // Attach scan meta if present
      win.__scanMeta = spec.meta || {};
      win.__scanNotes = spec.scanNotes || '';

      return win;
    }

    function open(id){
      if(openMap.has(id)){ bringToFront(openMap.get(id)); return openMap.get(id); }
      const spec = registry.get(id);
      if(!spec){ toast(`[err] no window named "${id}"`); return null; }
      const win = createShell(id, spec);
      const content = win.querySelector('.content');

      // render
      if(typeof spec.render === 'function'){
        spec.render(content, win);
      }else if(spec.html){
        content.innerHTML = spec.html;
      }else{
        content.innerHTML = `<p class="highlight">[info] ${id} ready.</p>`;
      }

      // add dock item
      win.__dockItem = addDockItem(id, spec.title ?? id);

      openMap.set(id, win);
      return win;
    }

    function close(id){
      const w = openMap.get(id); if(!w) return;
      w.remove(); openMap.delete(id); removeDockItem(w.__dockItem);
    }

    function allOpenIds(){ return [...openMap.keys()]; }
    function specOf(id){ return registry.get(id); }

    return { registerWindow, open, close, getWindowEl, allOpenIds, specOf };
  })();

  /* ---------------- Scan System ---------------- */
  const Scan = (() => {
    let enabled = false;
    let targetWin = null;

    const scanMetaRows = document.getElementById('scanMetaRows');
    const scanNotes = document.getElementById('scanNotes');
    const scanContrast = document.getElementById('scanContrast');

    scanContrast.addEventListener('input', ()=>{
      if(targetWin){
        const c = targetWin.querySelector('.content');
        c.style.filter = `contrast(${scanContrast.value}%)`;
      }
    });

    function setEnabled(on){
      enabled = on;
      document.body.classList.toggle('scan-enabled', enabled);
      if(!enabled && targetWin){
        targetWin.dataset.scanTarget = '';
        const c = targetWin.querySelector('.content');
        if(c) c.style.filter = '';
        targetWin = null;
      }
      toast(on ? '[sys] scan mode on' : '[sys] scan mode off');
    }

    function scanWindow(id){
      const w = WM.getWindowEl(id) || WM.open(id);
      if(!w) return;

      if(!enabled) setEnabled(true);

      // mark target for CSS reveals
      if(targetWin) targetWin.dataset.scanTarget='';
      targetWin = w;
      w.dataset.scanTarget = '1';

      // populate inspector with declared meta
      const meta = w.__scanMeta || {};
      scanMetaRows.innerHTML = '';
      Object.entries(meta).forEach(([k,v])=>{
        const row = document.createElement('div');
        row.innerHTML = `<span>${k}</span><span>:</span><span>${v}</span>`;
        scanMetaRows.appendChild(row);
      });
      scanNotes.textContent = w.__scanNotes || '';

      // reset contrast
      scanContrast.value = 100;
      const c = w.querySelector('.content');
      if(c) c.style.filter = 'contrast(100%)';
    }

    return { setEnabled, scanWindow, isEnabled:()=>enabled };
  })();

  /* ---------------- Listen stub ---------------- */
  function setListen(on){
    document.body.classList.toggle('listen-enabled', !!on);
    toast(on ? '[sys] listen enabled' : '[sys] listen disabled');
  }

  /* ---------------- State (journal lock, etc) ---------------- */
  const State = (() => {
    const key = 'arg-base-state';
    let state = { journalUnlocked:false, discovered:[] };
    try{ Object.assign(state, JSON.parse(localStorage.getItem(key)||'{}')); }catch{}
    function save(){ localStorage.setItem(key, JSON.stringify(state)); }
    function unlockJournal(){ state.journalUnlocked=true; save(); }
    function isJournalUnlocked(){ return !!state.journalUnlocked; }
    return { unlockJournal, isJournalUnlocked, save };
  })();

  /* ---------------- Commands ---------------- */
  const Commands = (() => {
    const reg = new Map(); // name -> {desc, usage, handler}
    function register(name, def){ reg.set(name, def); }
    function all(){ return [...reg.entries()].map(([k,v])=>({name:k,...v})); }

    // basic tokenizer w/ quotes
    function parse(input){
      const tokens = [];
      input.replace(/"([^"]+)"|'([^']+)'|(\S+)/g, (_,dq,sq,bare)=>{
        tokens.push(dq ?? sq ?? bare);
        return '';
      });
      const cmd = (tokens.shift()||'').toLowerCase();
      return { cmd, args: tokens };
    }

    async function exec(input){
      const {cmd, args} = parse(input);
      if(!cmd){ toast('[err] empty command'); return; }
      const def = reg.get(cmd);
      if(!def){ toast(`[err] unknown: ${cmd}`); return; }
      try{
        await def.handler(args);
      }catch(e){
        console.error(e);
        toast('[err] command failed');
      }
    }

    return { register, exec, all };
  })();

  /* ---------------- Built-in windows ---------------- */
  // Terminal
  WM.registerWindow('terminal',{
    title:'max bentley',
    x: 44*innerWidth/100, y: 30*innerHeight/100, w: 220, h: 160,
    render(el){
      el.classList.add('terminal');
      el.innerHTML = `
        <time id="clock"></time><br/>
        <p class="highlight" id="status">[info] waiting for user input<span class="blink">…</span></p>
        <input id="cmdline" type="text" autocomplete="off" spellcheck="false" placeholder="type help"/>
        <button id="go">go!</button>
      `;
      const clock = el.querySelector('#clock');
      const tick = ()=>{ clock.textContent = new Date().toLocaleString(); requestAnimationFrame(tick); }; tick();

      const input = el.querySelector('#cmdline');
      const status= el.querySelector('#status');
      function setStatus(msg){ status.textContent=''; status.innerHTML = `<span class="highlight">${msg}</span>`; }

      el.querySelector('#go').addEventListener('click', ()=> {
        const val = input.value.trim();
        if(!val){ setStatus('[err] empty'); return; }
        setStatus(`[sys] ${val}`);
        Commands.exec(val);
        input.value='';
        input.focus();
      });
      input.addEventListener('keydown', e=>{ if(e.key==='Enter') el.querySelector('#go').click(); });
    }
  });

  // Help
  WM.registerWindow('help',{
    title: 'help',
    x: 160, y: 140, w: 420, h: 260,
    render(el){
      const list = Commands.all().map(c=>`<li><strong>${c.name}</strong> — ${c.desc}${c.usage?` <em>${c.usage}</em>`:''}</li>`).join('');
      el.innerHTML = `
        <p class="highlight">[sys] command reference loaded.</p>
        <ul style="list-style:none;padding-left:0">${list}</ul>
        <p class="highlight">[tip] try: open about</p>
      `;
    }
  });

  // Example “about” window with scan-only content + overlay + meta
  WM.registerWindow('about',{
    title:'about',
    x: 80, y: 80, w: 420, h: 220,
    meta: { author:'system', description:'poem / orientation', version:'1.0' },
    scanNotes: 'acrostic lives on the left. overlay is decorative here.',
    render(el, win){
      el.innerHTML = `
        <p>Lone rooms keep their meanings, even after they’re cleared.</p>
        <p>I kept the order, not the things—edges taught me the shape.</p>
        <p>Stillness hums in the margins, if you stand and wait.</p>
        <p>The evening clicks like rain; listen and it will name the door.</p>
        <div class="scan-only" style="margin-top:6px">
          <p class="highlight">[scan] meta: try <strong>scan about</strong></p>
        </div>
        <div class="scan-overlay"></div>
      `;
    }
  });

  // Journal (locked by default)
  WM.registerWindow('journal',{
    title:'JOURNAL',
    x: 200, y: 120, w: 520, h: 320,
    render(el){
      const locked = !State.isJournalUnlocked();
      if(locked){
        el.innerHTML = `<p class="highlight">[lock] journal unavailable.</p><p>return when arrangement is accepted.</p>`;
      }else{
        el.innerHTML = `
          <p class="highlight">[sys] index</p>
          <ul style="list-style:none;padding-left:0">
            <li>about ✓</li>
            <li>…</li>
          </ul>`;
      }
    }
  });

  /* ---------------- Built-in commands ---------------- */
  Commands.register('help',{ desc:'show basic command list', handler:()=> WM.open('help') });

  Commands.register('open',{
    desc:'open a window by id',
    usage:'open <id>',
    handler: ([id])=>{
      if(!id) return toast('[err] open <id>');
      WM.open(id);
    }
  });

  Commands.register('scan',{
    desc:'toggle scan mode or target a window',
    usage:'scan [<id>]',
    handler: ([id])=>{
      if(id){
        Scan.scanWindow(id);
      }else{
        Scan.setEnabled(!Scan.isEnabled());
      }
    }
  });

  Commands.register('listen',{
    desc:'toggle listen lamp (stub)',
    handler: ()=>{
      const on = !document.body.classList.contains('listen-enabled');
      setListen(on);
    }
  });

  Commands.register('journal',{
    desc:'open the journal (locked until unlocked by game)',
    handler: ()=> WM.open('journal')
  });

  // Stubs you’ll wire later during puzzle implementation:
  Commands.register('mount',{ desc:'(stub) attach a virtual volume', usage:'mount <VOLUME>', handler: args=>toast(`[stub] mount ${args[0]||''}`) });
  Commands.register('trace',{ desc:'(stub) search stitched logs',    usage:'trace <term>',   handler: args=>toast(`[stub] trace ${args[0]||''}`) });
  Commands.register('tune', { desc:'(stub) phase aligner',          usage:'tune <code>',    handler: args=>toast(`[stub] tune ${args[0]||''}`) });

  /* ---------------- Public helpers you can call in puzzles ---------------- */
  window.ARG = {
    registerWindow: WM.registerWindow,
    open: WM.open,
    close: WM.close,
    unlockJournal(){
      State.unlockJournal();
      // if open, re-render
      const w = WM.getWindowEl('journal'); if(w){
        const c = w.querySelector('.content'); c.innerHTML=''; WM.specOf('journal').render(c);
      }
      toast('[ok] journal unlocked');
    },
    toast
  };

  /* ---------------- Boot: open terminal + help ---------------- */
  WM.open('terminal');
  WM.open('help');

})();
</script>
</body>
</html>
